REM >FindIBarS
REM 0.02 (26 Apr 1998)
REM
REM Needs BAX to assemble.

ON ERROR PRINT REPORT$;" at line ";ERL : END

REM The worskspace is laid out as follows:
REM
REM Offset Contents
REM ------ --------
REM      0 Task handle (task active flag)
REM      4 Task quit flag
REM      8 Pointer over Icon bar flag
REM     12 Pointer margin from screen base
REM     16 Poll block

task_handle=0
quit=4
pointer_in_bar=8
pointer_margin=12
misc_buffer=16
poll_block=32

code_space%=2000
DIM code% code_space%

FOR pass%=12 TO 14 STEP 2
L%=code%+code_space%
O%=code%
P%=0
[OPT pass%
          EQUD      task_code          ; Offset to task code
          EQUD      init_code          ; Offset to initialisation code
          EQUD      final_code         ; Offset to finalisation code
          EQUD      service_code       ; Offset to service-call handler
          EQUD      title_string       ; Offset to title string
          EQUD      help_string        ; Offset to help string
          EQUD      command_table      ; Offset to command table
          EQUD      0
          EQUD      0
          EQUD      0
          EQUD      0

; =============================================================================================

.title_string
          EQUZ      "FindIBar"
          ALIGN

.help_string
          EQUS      "Icon Bar Finder"
          EQUB      9
          EQUZ      "0.02 (26 Apr 1998) © Stephen Fryatt, 1998"
          ALIGN

; =============================================================================================

.command_table
          EQUZ      "Desktop_FindIBar"
          ALIGN
          EQUD      command_desktop
          EQUD      &00000000
          EQUD      0
          EQUD      0

          EQUZ      "IBarFind"
          ALIGN
          EQUD      0
          EQUD      &00010000
          EQUD      0
          EQUD      0

          EQUZ      "IBarMargin"
          ALIGN
          EQUD      command_margin
          EQUD      &00010000
          EQUD      command_margin_syntax
          EQUD      command_margin_help

          EQUD      0

; ---------------------------------------------------------------------------------------------

.command_desktop
          STMFD     R13!,{R14}

          MOV       R2,R0
          ADR       R1,title_string
          MOV       R0,#2
          SWI       "XOS_Module"

          LDMFD     R13!,{PC}

; ---------------------------------------------------------------------------------------------

.command_margin_help
          EQUS      "*"
          EQUB      27
          EQUB      0
          EQUS      " "
          EQUB      27
          EQUB      19
          EQUS      "size of"
          EQUB      27
          EQUB      2
          EQUS      "band at"
          EQUB      27
          EQUB      2
          EQUS      "base of"
          EQUB      27
          EQUB      2
          EQUS      "screen in which"
          EQUB      27
          EQUB      2
          EQUS      "pointer will bring"
          EQUB      27
          EQUB      2
          EQUS      "icon bar to"
          EQUB      27
          EQUB      2
          EQUS      "front."
          EQUB      13

.command_margin_syntax
          EQUB      27
          EQUB      30
          EQUS      "<margin>]"
          EQUB      0

.command_margin
          STMFD     R13!,{R14}

          LDR       R12,[R12]

          CMP       R1,#1
          BEQ       set_margin

.show_margin
          SWI       "XOS_WriteS"
          EQUZ      "Margin is "

          LDR       R0,[R12,#pointer_margin]
          ADRW      R1,misc_buffer
          MOV       R2,#16
          SWI       "XOS_BinaryToDecimal"

          MOV       R0,R1
          MOV       R1,R2
          SWI       "XOS_WriteN"

          SWI       "XOS_WriteS"
          EQUZ      " OS Units"
          SWI       "XOS_NewLine"

          LDMFD     R13!,{PC}

.set_margin
          MOV       R1,R0
          MOV       R0,#10
          SWI       "XOS_ReadUnsigned"

          STRVC     R2,[R12,#pointer_margin]
          BVC       margin_ok

.margin_error
          SWI       "XOS_WriteS"
          EQUZ      "This is not a valid margin size."
          SWI       "XOS_NewLine"

.margin_ok
          LDMFD     R13!,{PC}

; =============================================================================================

.init_code

          STMFD     R13!,{R14}

; Claim 296 bytes of workspace for ourselves and store the pointer in our private workspace.

          MOV       R0,#6
          MOV       R3,#296
          SWI       "XOS_Module"
          BVS       init_exit
          STR       R2,[R12]
          MOV       R12,R2

; Initialise the workspace:

          MOV       R0,#0
          STR       R0,[R12,#task_handle]

          MOV       R0,#2
          STR       R0,[R12,#pointer_margin]

.init_exit
          LDMFD     R13!,{PC}

; ---------------------------------------------------------------------------------------------

.final_code

          STMFD     R13!,{R14}
          LDR       R12,[R12]

; Kill the wimp task if it's running.

          LDR       R0,[R12,#task_handle]
          TEQ       R0,#0
          LDRGT     R1,task
          SWIGT     "XWimp_CloseDown"

; Free the workspace.

          TEQ       R12,#0
          BEQ       final_exit
          MOV       R0,#7
          MOV       R2,R12
          SWI       "XOS_Module"

.final_exit
          LDMFD     R13!,{PC}

; =============================================================================================

.service_code
          STMFD     R13!,{R14}
          LDR       R12,[R12]

.service_reset
          TEQ       R1,#&27
          MOVEQ     R14,#0
          STREQ     R14,[R12,#task_handle]
          BEQ       exit_service

.service_start_wimp
          TEQ       R1,#&49
          BNE       service_started_wimp

          LDR       R14,[R12,#task_handle]
          TEQ       R14,#0
          MVNEQ     R14,#NOT-1
          STREQ     R14,[R12,#task_handle]
          ADREQ     R0,command_desktop
          MOVEQ     R1,#0

          B         exit_service

.service_started_wimp
          LDR       R14,[R12,#task_handle]
          CMN       R14,#1
          MOVEQ     R14,#0
          STREQ     R14,[R12,#task_handle]

.exit_service
          LDMFD     R13!,{PC}

; =============================================================================================

.task
          EQUS      "TASK"

.wimp_version
          EQUD      310

.wimp_messages
          EQUD      0

.poll_mask
          EQUD      &1FFE

.misused_start_command
          EQUD      0
          EQUZ      "Use *Desktop to start FindIBar"
          ALIGN

; ---------------------------------------------------------------------------------------------

.task_code
          LDR       R12,[R12]

; Check we aren't in the Desktop

          SWI       "XWimp_ReadSysInfo"
          TEQ       R0,#0
          ADREQ     R0,misused_start_command
          SWIEQ     "OS_GenerateError"

; Kill any previous version of our task which may be running.

          LDR       R0,[R12,#task_handle]
          TEQ       R0,#0
          LDRGT     R1,task
          SWIGT     "XWimp_CloseDown"
          MOV       R0,#0
          STRGT     R0,[R12,#task_handle]

; Set the Quit flag to be zero.

          STR       R0,[R12,#quit]

; Initialise the module as a wimp task (again), remembering the task handle.

          LDR       R0,wimp_version
          LDR       R1,task
          ADR       R2,title_string
          ADR       R3,wimp_messages
          SWI       "XWimp_Initialise"
          SWIVS     "OS_Exit"
          STR       R1,[R12,#task_handle]

; Set the flag to False to say that the pointer is not over the Icon Bar.

          MOV       R0,#0
          STR       R0,[R12,#pointer_in_bar]

; Point R1 to the poll_block

          ADRW      R1,poll_block

; ---------------------------------------------------------------------------------------------

.poll_loop
          SWI       "OS_ReadMonotonicTime"
          ADD       R2,R0,#50
          LDR       R0,poll_mask
          SWI       "Wimp_PollIdle"

; Deal with a null event.

          TEQ       R0,#0
          BLEQ      null_event

; If it is a message 17 or 18 and code is 0 set the quit flag.

          TEQ       R0,#17
          TEQNE     R0,#18
          LDREQ     R0,[R1,#16]
          TEQEQ     R0,#0
          MOVEQ     R0,#1
          STREQ     R0,[R12,#quit]

; Continue to poll until the quit flag is true.

          LDR       R0,[R12,#quit]
          TEQ       R0,#0
          BEQ       poll_loop

; ---------------------------------------------------------------------------------------------

.close_down
          LDR       R0,[R12,#task_handle]
          LDR       R1,task
          SWI       "XWimp_CloseDown"

; Having exited, set task_handle to zero and die.

          MOV       R0,#0
          STR       R0,[R12,#task_handle]

          SWI       "OS_Exit"

; =============================================================================================

.shift_f12
          EQUD      &1DC

; ---------------------------------------------------------------------------------------------

.null_event
          SWI       "Wimp_GetPointerInfo"

; Check if we think the pointer is in the bar or not...

          LDR       R2,[R12,#pointer_in_bar]
          TEQ       R2,#0
          BEQ       not_in_bar

.in_bar
          LDR       R2,[R1,#12]                   ; Is the window under the pointer
          CMN       R2,#2                         ; the icon bar (-2)?
          MOVEQ     PC,R14                        ; If so, do nothing more.

          MOV       R2,#0                         ; Unset the pointer_in_bar flag to show
          STR       R2,[R12,#pointer_in_bar]      ; that the pointer is out of the bar

          MVN       R2,#NOT-2                     ; Get the window flags for the icon bar.
          STR       R2,[R1]
          SWI       "Wimp_GetWindowState"

          LDR       R0,shift_f12                  ; Do a Shift-F12. This will either put the
          SWI       "Wimp_ProcessKey"             ; bar to the back or bring it to the front.

          LDR       R2,[R1,#32]                   ; Was the icon bar obscured *before* the
          AND       R2,R2,#&20000                 ; first Shift-F12. If so, it will now be
          TEQ       R2,#0                         ; on top after one Shift-F12 and will need
          LDREQ     R0,shift_f12                  ; another to put it to the bottom as
          SWIEQ     "Wimp_ProcessKey"             ; required.

          MOV       PC,R14

.not_in_bar
          LDR       R2,[R1,#4]                    ; Is pointer_y < pointer_margin?
          LDR       R3,[R12,#pointer_margin]
          CMP       R2,R3
          MOVGE     PC,R14                        ; If not, quit.

          MOV       R2,#1                         ; Set the pointer_in_bar flag to show that
          STR       R2,[R12,#pointer_in_bar]      ; the pointer is over the bar.

          MVN       R2,#NOT-2                     ; Get the icon bar's window flags
          STR       R2,[R1]
          SWI       "Wimp_GetWindowState"

          LDR       R2,[R1,#32]                   ; If the bar is obscured, do a Shift-F12
          AND       R2,R2,#&20000                 ; to bring it to the front.
          TEQ       R2,#0
          LDREQ     R0,shift_f12
          SWIEQ     "Wimp_ProcessKey"

          MOV       PC,R14
]
NEXT pass%

SYS "OS_File",10,"<Basic$Dir>.FindIBar",&FFA,,code%,code%+P%
